import Book from "../models/book.model.js";
import Transaction from "../models/transaction.model.js";
import User from "../models/user.model.js";

//Issue a book to a user
const issueBook = async (req, res) => {
  try {
    const { bookName, userId, issueDate } = req.body;

    const book = await Book.findOne({ name: bookName });
    if (!book) {
      return res.status(404).json({ message: 'Book not found' });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    const transaction = new Transaction({
      book: book._id,
      user: user._id,
      issueDate,
    });

    const createdTransaction = await transaction.save();

    res.status(201).json(createdTransaction);

  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Return a book and calculate rent
const returnBook = async (req, res) => {
  try {
    const { bookName, userId, returnDate } = req.body;

    const book = await Book.findOne({ name: bookName });
    if (!book) {
      return res.status(404).json({ message: 'Book not found' });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    const transaction = await Transaction.findOne({
      book: book._id,
      user: user._id,
      returnDate: { $exists: false },
    });

    if (!transaction) {
      return res.status(404).json({ message: 'No active transaction found for this book and user' });
    }

    const issueDate = transaction.issueDate;

    // Validate that returnDate is not before issueDate
    if (new Date(returnDate) < new Date(issueDate)) {
      return res.status(400).json({ message: 'Return date cannot be before issue date' });
    };

    const rentDuration = Math.ceil(
      (new Date(returnDate) - new Date(issueDate)) / (1000 * 60 * 60 * 24)
    );

    const rent = rentDuration * book.rentPerDay;

    transaction.returnDate = returnDate;
    transaction.rent = rent;

    const updatedTransaction = await transaction.save();

    res.status(200).json(updatedTransaction);

  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get people who issued the book in the past and current status
const getBookStatus = async (req, res) => {
  try {
    const { bookName } = req.query;

    const book = await Book.findOne({ name: bookName });
    if (!book) {
      return res.status(404).json({ message: 'Book not found' });
    }

    const transactions = await Transaction.find({ book: book._id }).populate('user', 'name');

    const currentlyIssued = await Transaction.findOne({
      book: book._id,
      returnDate: { $exists: false },
    }).populate('user', 'name');

    res
    .status(200)
    .json({
      totalIssued: transactions.length,
      currentlyIssued: currentlyIssued ? currentlyIssued.user.name : 'Not issued',
      issuedList: transactions.map((t) => t.user.name),
    });

  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get total rent generated by a book
const getTotalRentByBook = async (req, res) => {
  try {
    const { bookName } = req.query;

    const book = await Book.findOne({ name: bookName });
    if (!book) {
      return res.status(404).json({ message: 'Book not found' });
    }

    const transactions = await Transaction.find({ book: book._id });

    const totalRent = transactions.reduce((sum, t) => sum + (t.rent || 0), 0);

    res.status(200).json({ totalRent });

  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get books issued to a person
const getBooksByUser = async (req, res) => {
  try {
    const { userId } = req.query;

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    const transactions = await Transaction.find({ user: user._id }).populate('book', 'name');

    if(transactions.length == 0){
      return res.status(404).json({ message: 'No book issued to this person' });
    }

    res.status(200).json(transactions.map((t) => t.book.name));

  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get books issued in a date range
const getBooksIssuedInDateRange = async (req, res) => {
  try {
    const { startDate, endDate } = req.query;

    const transactions = await Transaction.find({
      issueDate: {
        $gte: new Date(startDate),
        $lte: new Date(endDate),
      },
    }).populate('book user', 'name');

    if(transactions.length == 0){
      return res.status(404).json({ message: 'No book issued in the given date range' });
    }

    res
    .status(200)
    .json(transactions.map((t) => ({
      book: t.book.name,
      issuedTo: t.user.name,
    })));
    
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

export {
  issueBook,
  returnBook,
  getBookStatus,
  getTotalRentByBook,
  getBooksByUser,
  getBooksIssuedInDateRange,
};
